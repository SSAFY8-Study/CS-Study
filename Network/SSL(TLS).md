# **📎 SSL/TLS**

### **개념**

-   SSL은 1995년 Netscape 사의 웹 브라우저 보안 프로토콜로 처음 등장하였고,  
    1999년 IETF에 의해 SSL 3.1을 표준화한 TLS 버전 1.0이 발표되었다.  
    👉 SSL과 TSL은 통상적으로 같은 의미로 쓰인다.
-   SSL/TLS을 사용하여 암호화된 연결을 하는 HTTP를 HTTPS라고 한다.
-   대칭키, 비대칭키 암호화의 단점을 보완한다.

```
📍 대칭키, 비대칭키 암호화 방식
  
(1) 대칭키 암호화
  암호화, 복호화에 사용되는 키가 동일하다.  
  비대칭키 암호화 방식에 비해 속도가 빠르다는 장점이 있지만,  
  처음 키를 교환하는 과정에서 키 탈취에 의한 보안 약점이 존재한다.  
  
(2) 비대칭키 암호화
  암호화, 복호화에 사용되는 키가 다르다.  
  대칭키 암호화 방식에 비해 속도가 느리다는 단점이 있지만,  
  대칭키 암호화 방식의 키 교롼 문제를 해결할 수 있다.  
 
✔️ 비대칭키 암호화 방식 설명
  공개키와 개인키를 가지는데,  
  공개키는 모든 사용자가 접근 가능한 키이며, 개인키는 각 사용자만이 가지는 키이다.  
   
1) A와 B 사용자가 있다고 할 때, B가 공개키/개인키 쌍을 생성한다.  
2) A가 B로 접속 요청을 보낸다.  
3) B는 A에게 자신의 공개키를 전송한다.  
4) A가 B의 공개키를 사용하여 데이터를 암호화한다.  
5) 암호화된 데이터를 B에게 전송한다.  
6) B는 암호화된 데이터를 B의 개인키로 복호화한다.  
👉 공개키와 쌍을 이루는 개인키만이 복호화할 수 있으므로, B만이 데이터를 볼 수 있다.
```

</br>

### **SSL/TLS의 암호화 방식**

SSL/TLS는 대칭키, 비대칭키 방식을 혼합하여 사용함으로써 그 단점을 극복한다.

처음 키 교환 시에만 비대칭키 방식을 사용하고, 이후로는 대칭키 방식을 사용한다.

- A와 B 사용자가 있다고 할 때, B는 공개키/개인키 쌍을 생성한다.
- A가 B로 접속 요청을 보낸다.
- B는 A에게 자신의 공개키를 전송한다.
- A는 자신의 대칭키를 B에서 전달 받은 B의 공개키로 암호화한다.
- 암호화한 다신의 대칭키를 B에게 전달한다.
- B는 자신의 개인키로 복호화하여 A의 대칭키를 얻는다.
- 얻은 대칭키를 활용하여 A와 B는 안전하고 빠르게 대칭키 암호화 방식으로 통신한다.

</br>

### **SSL/TLS Handshake**

통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요한 정보를 주고 받는 과정이다.

아래는 Handshake 과정을 표현한 그림이다. 파란 칸과 노란 칸은 네트워크 상에서 전달되는 IP 패킷이다.

-   파란 칸은 TCP 레이어의 3-Way Handshake로, HTTPS는 TCP 기반의 프로토콜이므로  
    SSL/TLS Handshake에 앞서 연결 생성을 위해 실시하는 과정이다.
-   노란 칸에 해당하는 패킷들이 SSL/TLS Handshake이다.

![image](https://user-images.githubusercontent.com/59721896/195625564-3cf010e3-b6f4-4910-b483-0812ac523b63.png)

-   **ClientHello**  
    클라이언트가 서버에 연결을 시도하며 전송한다.
-   **ServerHello**  
    서버는 클라이언트가 보낸 ClientHello 패킷을 받고, 클라이언트에게 알린다. 
-   **Certificate**  
    서버는 자신의 인증서를 클라이언트에게 전달한다. (서버의 공개키가 들어있다.)  
    클라이언트는 서버가 보낸 암호화된 인증서를 CA의 공개키로 복호화한다.  
    👉 복호화 성공 시 해당 인증서는 CA가 서명한 것이 맞으니 진짜임이 검증된다.
-   **ServerKeyExchange**  
    서버의 공개키가 인증서 내부에 없다면, 서버가 직접 전달한다는 뜻으로,  
    ServerKeyExchange가 필요하지만, 반대의 경우에는 ServerKeyExchange는 생략된다.
-   **ServerHelloDone**  
    인증서 내부에 서버의 공개키가 있다면, 클라이언트가 CA의 공개키를 통해 인증서를 복호화한 후  
    서버의 공개키를 확보할 수 있다. 그리고 서버가 행동을 마쳤음을 전달한다.
-   **ClientKeyExchange**  
    클라이언트는 데이터 암호화에 사용할 대칭키를 생성한 후,  
    인증서 내부에서 추출한 서버의 공개키를 이용하여 암호화하여 서버에게 전달한다.  
    👉 여기서 전달된 대칭키가 Handshake의 목적이자, 실제로 데이터를 암호화할 키이다.
-   **ChangeCipherSpec**  
    교환해야 할 정보를 모두 교환한 뒤, 모든 준비가 완료되었음을 알리는 패킷이다.
-   **Finished**  
    HandShake를 종료한다.

</br>

### **SSL/TLS이 제공하는 보안 서비스**

-   **기밀성**  
    대칭키, 비대칭키 암호화 방식을 사용하여 기밀성을 제공한다.
-   **무결성**  
    데이터 위변조를 확인한다.
-   **인증**  
    연결 초기 설정에서 주고 받는 인증서를 통해 신뢰할 수 있는 사용자인지 보장할 수 있다.

</br>

참고

-   [https://steady-coding.tistory.com/512](https://steady-coding.tistory.com/512)
-   [https://brownbears.tistory.com/402](https://brownbears.tistory.com/402)
-   [https://howhttps.works/ko/https-ssl-tls-differences/](https://howhttps.works/ko/https-ssl-tls-differences/)
-   [https://liveyourit.tistory.com/183](https://liveyourit.tistory.com/183)
